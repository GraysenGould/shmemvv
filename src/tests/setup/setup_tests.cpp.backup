/**
  @file setup_tests.cpp
  @brief Contains OpenSHMEM setup tests.
 */

#include "setup_tests.hpp"

bool test_shmem_fake_routine(void) {
  if (p_shmem_fake_routine) {
    p_shmem_fake_routine();
    return true;
  }
  else {
    std::cerr << "shmem_fake_routine is not available." << std::endl;
    return false;
  }
}

/**
  @brief Tests the initialization of OpenSHMEM.
  @return True if the initialization is successful, false otherwise.
 */
bool test_shmem_init() {
  p_shmem_init();
  return true;
}

/**
  @brief Tests the barrier synchronization across all PEs.
  @return True if the barrier synchronization is successful, false otherwise.
 */
bool test_shmem_barrier_all() {
  int mype = p_shmem_my_pe();
  int npes = p_shmem_n_pes();
  
  long *sync = (long *)p_shmem_malloc(sizeof(long));
  if (sync == nullptr) {
    return false;
  }

  *sync = mype;

  p_shmem_barrier_all();

  bool test_passed = true;

  if (*sync != mype) {
    test_passed = false;
  }

  p_shmem_free(sync);
  return test_passed;
}

/**
  @brief Tests the shmem_barrier() routine.
  @return True if the test is successful, false otherwise.
 */
bool test_shmem_barrier(void) {
  static long pSync[SHMEM_BARRIER_SYNC_SIZE];
  for (int i = 0; i < SHMEM_BARRIER_SYNC_SIZE; i++) {
    pSync[i] = SHMEM_SYNC_VALUE;
  }

  p_shmem_barrier(0, 0, p_shmem_n_pes(), pSync);
  return true;
}

/**
  @brief Tests retrieving the PE number of the calling PE.
  @return The PE number on success, -1 on failure.
 */
int test_shmem_my_pe() {
  int mype = p_shmem_my_pe();
  if (mype >= 0) {
    return mype;
  }
  else {
    return -1;
  }
}

/**
  @brief Tests retrieving the number of PEs.
  @return The number of PEs if greater than 0, otherwise 0.
 */
int test_shmem_n_pes() {
  int npes = p_shmem_n_pes();
  if (!(npes > 0)) {
    return 0;
  }
  else {
    return npes;
  }
}

/**
  @brief Tests if a PE is accessible from the calling PE.
  @return True if all PEs are accessible, false otherwise.
 */
bool test_shmem_pe_accessible() {
  int npes = p_shmem_n_pes();
  for (int pe = 0; pe < npes; ++pe) {
    if (!p_shmem_pe_accessible(pe)) {
      return false;
    }
  }
  return true;
}

/**
  @brief Tests retrieving the OpenSHMEM library version.
  @return The version as a string in the format "major.minor".
 */
std::string test_shmem_info_get_version() {
  char version[SHMEM_MAX_NAME_LEN];
  if (p_shmem_info_get_version) {
    std::cout << "Calling p_shmem_info_get_version..." << std::endl;
    p_shmem_info_get_version(version, sizeof(version));
    std::cout << "Version retrieved: " << version << std::endl;
    return std::string(version);
  } else {
    std::cerr << "p_shmem_info_get_version is not available." << std::endl;
    return "";
  }
}

/**
  @brief Tests retrieving the name of the OpenSHMEM library.
  @return The name of the library as a string if successful, otherwise an empty string.
 */
std::string test_shmem_info_get_name() {
  char name[SHMEM_MAX_NAME_LEN];
  if (p_shmem_info_get_name) {
    std::cout << "Calling p_shmem_info_get_name..." << std::endl;
    p_shmem_info_get_name(name, sizeof(name));
    std::cout << "Name retrieved: " << name << std::endl;
    if (strlen(name) > 0) {
      return std::string(name);
    } else {
      return "";
    }
  } else {
    std::cerr << "p_shmem_info_get_name is not available." << std::endl;
    return "";
  }
}

/**
  @brief Tests the finalization of OpenSHMEM.
  @return True if the finalization is successful, false otherwise.
 */
bool test_shmem_finalize() {
  p_shmem_finalize();
  return true;
}

/**
  @brief Tests the global exit functionality of OpenSHMEM.
  @return True if the global exit is successful, false otherwise.
 */
bool test_shmem_global_exit() {
  p_shmem_global_exit(0);
  return true;
}
